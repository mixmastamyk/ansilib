#!/usr/bin/env python3
'''
    console - Comprehensive utility library for ANSI terminals.
    © 2018-2020, Mike Miller - Released under the LGPL, version 3+.

    Convenience command-line interface script for select utility functions and
    methods that don't have common implementations.
    (Optional arguments may be shortened and are recognized when unique.)
'''
import sys, os
import logging
from importlib import import_module
from inspect import signature

from console import fg, fx
from console.meta import __version__


log = logging.getLogger(__name__)
commands_dict = dict(
    # function            module or function
    clear_lines         = 'console.utils',
    flash               = 'console.utils',
    line                = ('make_line',),  # alias
    link                = ('make_hyperlink',),  # alias
    make_hyperlink      = 'console.utils',
    make_line           = 'console.utils',
    notify_cwd          = 'console.utils',
    set_title           = 'console.utils',
)
if os.name == 'nt':
    pass # os.EX_OK, os.EX_SOFTWARE = 0, 70  # :-/


def _add_sub_args(parameters, sub_parser, allow_kwargs):
    ''' Given function signature parameters, add to parser. '''

    for name, param in parameters.items():

        if name.startswith('_'):  # skip these
            continue

        prefix = '--'  # defaults
        type_ = str
        if param.annotation is not param.empty:  # allow override
            type_ = param.annotation
        elif param.kind.name == 'VAR_KEYWORD':  # **kwargs
            allow_kwargs = True
            continue
        elif param.default is None:
            pass
        elif param.default is param.empty:
            prefix = ''
        else:
            type_ = type(param.default)

        # figure params to the sub_parser argument:
        sub_args = dict(
            default=param.default,
            help=str(type_.__name__),
        )
        if type_ is bool:
            sub_args['action'] = 'store_true'
        elif param.default is param.empty:
            sub_args['type'] = type_
        else:
            sub_args['type'] = type_
            #~ sub_args['metavar'] = name[0].upper()
            sub_args['metavar'] = type_.__name__[0].upper()

        if '-v' in sys.argv:  # avoid passing another var :-/
            print('  param:', (fg.green + fx.bold)(name))
            print('    default: %r' % param.default)
            print('    annotat:', param.annotation)
            print('    kind   :', param.kind.name)
            print('    type   :', type_)
            print('    sub add_argument:', sub_args)

        sub_parser.add_argument(prefix + name, **sub_args)

    return allow_kwargs


def _get_action_help(choices):
    ''' Build the action list help string. '''
    from textwrap import fill

    actions = [ fg.green(ac) for ac in choices ]
    return fill('{%s}' % ', '.join(actions), width=90)  # wider due to escapes


def _parse_extras(parser, extras):
    ''' Given a list of '--key', 'value' strings, return a dictionary. '''
    new = {}
    keys = []
    for arg in extras:
        if arg.startswith('--'):
            suffix = arg[2:]
            key, _, val = suffix.partition('=')  # --name=value form?
            if val:
                new[key] = val
            else:
                keys.append(suffix)
        elif keys:
            new[keys.pop()] = arg
        else:
            parser.error('no extra positional arguments allowed: %r' % arg)

    return new


def setup():
    ''' Parse command line, validate, initialize logging, etc. '''
    from argparse import ArgumentParser, RawTextHelpFormatter as RawFormatter

    # text styles
    op, n = fx.dim, fx.end  # options, normal
    opv = fx.italic + op  # variable/abstract in italic
    ac = fg.lightgreen  # actions
    acv = fx.italic + ac
    _action = acv('action')

    action_choices = sorted(set(commands_dict))
    action_help = _get_action_help(action_choices)

    # build top-level parser
    parser = ArgumentParser(
        add_help=False, description=__doc__, formatter_class=RawFormatter,
        usage=f'%(prog)s {op}-v{n} {op}--version{n} {_action} {opv}options…{n}',
    )
    parser.add_argument(
        'action', nargs='?', choices=action_choices,
        metavar=_action + '  ',  # clear clumsy action help, better fmt-ing:
        help='   one of ' + action_help +
            f'\n(use {_action} {op}-h{n} for specific help)',
    )
    parser.add_argument(
        '-v', '--verbose', action='store_const', dest='loglvl',
        default=logging.INFO, const=logging.DEBUG,
        help='print additional information',
    )
    parser.add_argument(
        '--version', action='version', version='%(prog)s ' + __version__
    )
    # parse and validate
    args, extras = parser.parse_known_args()  # don't complain about extras

    # start logging
    logging.basicConfig(
        level=args.loglvl,
        stream=sys.stdout,
        format='  %(levelname)-8.8s %(message)s',
    )
    logging.captureWarnings(True)
    log.debug('extr: %s', extras)
    log.debug('args: %s', args)

    if args.action:
        # Build a sub parser with a new parser, so we don't have to build a
        # sub parser for every conceivable command at start up only to
        # pick one, also simplifies a few things:
        sub_parser = ArgumentParser(
            description=None, formatter_class=RawFormatter,
            usage='%%(prog)s %s [args…] [options…]' % args.action,
        )
        allow_kwargs = False
        # find module and function
        funcname = args.action
        modname = commands_dict[funcname]
        if type(modname) is tuple:  # for aliases, modname is function name
            funcname = modname[0]
            modname = commands_dict[funcname]  # try again

        # load, store, and inspect signature
        mod = import_module(modname)
        funk = getattr(mod, funcname)
        sub_parser.set_defaults(_funk=funk)
        sig = signature(funk)

        allow_kwargs = _add_sub_args(sig.parameters, sub_parser, allow_kwargs)

        # parse and validate again!
        if allow_kwargs:
            args, extras = sub_parser.parse_known_args(extras)
            kwargs = _parse_extras(sub_parser, extras)
        else:
            args, kwargs = sub_parser.parse_args(extras), {}

    else:
        parser.print_help()
        sys.exit(os.EX_USAGE)

    return args, kwargs


def main(args, kwargs):
    ''' Tear the roof off the sucker… '''
    status = os.EX_OK

    try:  # Ow, we want the funk…
        options = vars(args)
        funk = options.pop('_funk', None)  # Give up the funk

        if funk:
            log.debug('running: %s %s', funk, options)
            result = funk(**options, **kwargs)
            print(result, end='\n')
            log.debug('result was: %r', result)

    except Exception:
        log.exception('Unexpected error occurred:')
        status = os.EX_SOFTWARE

    # You've got a real type of thing going down, gettin' down
    # There's a whole lot of rhythm going round…
    log.debug('done, with status: %r', status)
    return status


if __name__ == '__main__':

    sys.exit(main(*setup()))

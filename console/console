#!/usr/bin/env python3
'''
    .. console - Comprehensive utility library for ANSI terminals.
    .. © 2018-2020, Mike Miller - Released under the LGPL, version 3+.

    Convenience command-line interface script for select utility functions and
    methods.
'''
import sys, os
import logging
from importlib import import_module
from inspect import signature


__version__ = '0.50'
log = logging.getLogger(__name__)
commands = (
    # module            function    aliases
    ('console.utils', 'make_line', ('line',)),
    ('console.utils', 'make_hyperlink', ('link',)),
)


def setup():
    ''' Parse command line, validate, initialize logging, etc. '''
    from argparse import ArgumentParser, RawTextHelpFormatter

    parser = ArgumentParser(
        description=__doc__, formatter_class=RawTextHelpFormatter
    )
    parsers = parser.add_subparsers(
        description='the following subcommand actions are supported:',
        #~ dest='action',  # if action is needed
        required=True,
        title='actions',
        #~ help='action help',
    )

    for modname, funcname, aliases in commands:

        func_parser = parsers.add_parser(
            funcname,
            aliases=aliases,
            help=f'{funcname} help',
        )
        mod = import_module(modname)
        funk = getattr(mod, funcname)
        func_parser.set_defaults(_funk=funk)
        sig = signature(funk)

        for param_name in sig.parameters:

            if param_name.startswith('_'):
                continue

            param = sig.parameters[param_name]
            #~ print('  param:', param_name)
            #~ print('    default: %r' % param.default)
            #~ print('    annotat: ', param.annotation)
            #~ print('    kind    :', param.kind)

            prefix = '--'
            if param.annotation is not param.empty:  # allow override
                type_ = param.annotation
            elif param.default is None:
                type_ = str
            elif param.default is param.empty:
                type_ = str
                prefix = ''
            else:
                type_ = type(param.default)
            #~ print('    type   :', type_)

            sub_args = dict(
                default=param.default,
                help=str(type_.__name__),
            )
            if type_ is bool:
                sub_args['action'] = 'store_true'
            elif param.default is param.empty:
                sub_args['type'] = type_
            else:
                sub_args['type'] = type_
                sub_args['metavar'] = param_name[0].upper()

            #~ print('  subargs:', sub_args)
            func_parser.add_argument(prefix + param_name, **sub_args)

    # common stuff
    parser.add_argument(
        '-v', '--verbose', action='store_const', dest='loglvl',
        default=logging.INFO, const=logging.DEBUG,
        help='print additional information',
    )
    parser.add_argument(
        '--version', action='version', version='%(prog)s ' + __version__
    )

    # parse and validate
    args = parser.parse_args()
    args.verbose = args.loglvl == logging.DEBUG
    if args.verbose:
        pass

    # start logging
    logging.basicConfig(
        level=args.loglvl,
        stream=sys.stdout,
        format='  %(levelname)-8.8s %(message)s',
    )
    logging.captureWarnings(True)
    log.debug('args: %s', args)

    return args


def main(args):
    ''' Tear the roof off the sucker… '''
    status = os.EX_OK

    try:  # Ow, we want the funk…
        options = vars(args)
        funk = options.pop('_funk', None)  # Give up the funk
        del options['loglvl']
        del options['verbose']

        if funk:
            log.debug('running: %s %s', funk, options)
            print(funk(**options))

    except Exception as err:
        # os.EX_DATAERR os.EX_NOINPUT os.EX_CANTCREAT os.EX_IOERR os.EX_CONFIG
        print(err)

    # You've got a real type of thing going down, gettin' down
    # There's a whole lot of rhythm going round…
    log.debug('done, with status: %r', status)
    return status


if __name__ == '__main__':

    sys.exit(main(setup()))
